#include "precompiled_GFXAdapter_OpenGLES2.h"

///////////////////////////////////////////////////////////////////////////////
///////////////////////       implementation of various shapes drawing
///////////////////////////////////////////////////////////////////////////////

#ifndef _ITF_OPENGLES2_DRAWPRIM_H_
#include "adapters/GFXAdapter_OpenGLES2/GFXAdapter_OpenGLES2.h"
#endif //_ITF_OPENGLES2_DRAWPRIM_H_

#ifndef _ITF_FILE_H_
#include "core/file/File.h"
#endif //_ITF_FILE_H_

#ifndef _ITF_FILEMANAGER_ITF_H_
#include "adapters/FileManager_ITF/FileManager_ITF.h"
#endif //_ITF_FILEMANAGER_ITF_H_

#ifdef CHECK_SHADERS_VALIDITY
#include "engine/display/ShaderParameterDBDesc.h"
#endif // CHECK_SHADERS_VALIDITY

#ifndef _ITF_CAMERA_H_
#include "engine/display/Camera.h"
#endif //_ITF_CAMERA_H_

namespace ITF
{

// Attributes Locations are constants through all the shaders
// generated by HLSL2GLSL tool :
// char* AttribSemanticList[] =
// {
//     "POSITION;POSITION0;",                  //0,
//     ";",                                    //1,
//     "NORMAL;NORMAL0;",                      //2,
//     "COLOR0;COLOR;",                        //3,
//     "COLOR1;",                              //4,
//     "FOGCOORD;BLENDWEIGHT;BLENDWEIGHT0;",   //5,
//     "PSIZE;PSIZE0;BLENDWEIGHT1;",           //6,
//     "BLENDINDICES;BLENDINDICES0;",          //7,
//     "TEXCOORD0;TEXCOORD;",                  //8,
//     "TEXCOORD1;",                           //9,
//     "TEXCOORD2;",                           //10,
//     "TEXCOORD3;",                           //11,
//     "TEXCOORD4;",                           //12,
//     "TEXCOORD5;",                           //13,
//     "TANGENT;TANGENT0;TEXCOORD6;",          //14,   // <=> GCMDECLUSAGE_TEXCOORD6
//     "BINORMAL;BINORMAL0;TEXCOORD7;",        //15,   // <=> GCMDECLUSAGE_TEXCOORD7
// 
// };

 	// ------------------------------------------------------------------------------

#if 0 //DEAC
	GFXAdapter_OpenGLES2::shAttr GFXAdapter_OpenGLES2::shAttrArray[shAI_Max] = {
		{ 0, sizeof(Vec3d),       GX2_ATTRIB_FORMAT_32_32_32_FLOAT   }  // shAI_vPos
	   ,{ 2, sizeof(Vec3d),       GX2_ATTRIB_FORMAT_32_32_32_FLOAT   }  // shAI_vNrm
	   ,{ 3, sizeof(u32),         GX2_ATTRIB_FORMAT_8_8_8_8_UNORM    }  // shAI_fColor
	   ,{ 5, sizeof(u32),         GX2_ATTRIB_FORMAT_8_8_8_8_UNORM    }  // shAI_vBlendW
	   ,{ 7, sizeof(u32),         GX2_ATTRIB_FORMAT_8_8_8_8_SINT     }  // shAI_vChnl
	   ,{ 8, sizeof(Vec2d),       GX2_ATTRIB_FORMAT_32_32_FLOAT      }  // shAI_vTexCoord0
	   ,{ 9, sizeof(GFX_Vector4), GX2_ATTRIB_FORMAT_32_32_32_32_FLOAT}  // shAI_uv2
	   ,{10, sizeof(GFX_Vector4), GX2_ATTRIB_FORMAT_32_32_32_32_FLOAT}  // shAI_uv3
	   ,{11, sizeof(Vec2d),       GX2_ATTRIB_FORMAT_32_32_FLOAT      }  // shAI_uv4
	   ,{12, sizeof(Vec2d),       GX2_ATTRIB_FORMAT_32_32_FLOAT      }  // shAI_uv5
	};
#endif
 	// ------------------------------------------------------------------------------

	bbool GFXAdapter_OpenGLES2::loadCoreShaders()
	{
		LockRendering();
		syncGPU();
		cleanSetShaderCache();
		//DEAC GX2SetShaderMode(GX2_SHADER_MODE_UNIFORM_REGISTER);
		UnlockRendering();

		bbool success = Super::loadCoreShaders();

		return success;
	}

 	// ------------------------------------------------------------------------------

	bbool GFXAdapter_OpenGLES2::loadShader(ITF_shader* _shaderGroup)
	{
		_shaderGroup->generateShaders();
		return btrue;
	}

 	// ------------------------------------------------------------------------------

	void* GFXAdapter_OpenGLES2::loadBinVShader(u8* _binShader, ux _binSize)
	{
		GLES2VertexShader *shader = NULL;

		// Load vs code
		if(!loadVShaderFromMemory(&shader, _binShader, _binSize))
		{
			LOG("[SHADER] Vertex Shader failure.");
		}
/*#ifdef CHECK_SHADERS_VALIDITY
		else
		{        
			// Check Uniform Variables
			for(u32 i=0 ; i<shader->numUniforms ; ++i)
			{
				CheckUniformVar(m_vsDBDesc, &shader->uniformVars[i]);
			}

			// Check Attributes
			for(u32 i=0 ; i<shader->numAttribs ; ++i)
			{
				if(!CheckAttribVar(&shader->attribVars[i]))
				{
					LOG("[SHADER] Attrib var error");
				}
			}
		}
#endif // CHECK_SHADERS_VALIDITY*/

		return (void *)shader;
	}

 	// ------------------------------------------------------------------------------

	void* GFXAdapter_OpenGLES2::loadBinPShader(u8* _binShader, ux _binSize)
	{
		GLES2PixelShader *shader = NULL;

		// load ps code
		if(!loadPShaderFromMemory(&shader, _binShader, _binSize))
		{
			LOG("[SHADER] Pixel Shader failure.");
		}
/*#ifdef CHECK_SHADERS_VALIDITY
		else
		{
			// Check Uniform Variables
			for(u32 i=0 ; i<shader->numUniforms ; ++i)
			{
				CheckUniformVar(m_psDBDesc, &shader->uniformVars[i]);
			}

			// Check Samplers
			for(u32 i=0 ; i<shader->numSamplers ; ++i)
			{
				CheckSamplerVar(&shader->samplerVars[i]);
			}
		}
#endif // CHECK_SHADERS_VALIDITY*/

		return (void *)shader;
	}


	GLuint compileShader(GLenum shaderType, const char* pSource)
	{
		GLuint shader = glCreateShader(shaderType);
		if (shader)
		{
			GL_CHECK( glShaderSource(shader, 1, &pSource, NULL) );
			GL_CHECK( glCompileShader(shader) );
			GLint compiled = 0;
			GL_CHECK( glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled) );
			if (!compiled)
			{
				GLint infoLen = 0;
				GL_CHECK( glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen) );
				if (infoLen)
				{
					char* buf = (char*) malloc(infoLen);
					if (buf)
					{
						GL_CHECK( glGetShaderInfoLog(shader, infoLen, NULL, buf) );
						//OGE("Could not compile shader %d:\n%s\n", shaderType, buf);
						free(buf);
					}
	                
					GL_CHECK( glDeleteShader(shader) );
					shader = 0;
				}
			}
		}
		return shader;
	}

	// ------------------------------------------------------------------------------
	bbool GFXAdapter_OpenGLES2::loadVShaderFromMemory(GLES2VertexShader **_ppDst, const void *_pSrc, ux _binSize)
	{
		GLES2VertexShader *shader;
		GLuint shaderId = compileShader(GL_VERTEX_SHADER, (const char*)_pSrc);

		if ( shaderId )
		{
			shader = newAlloc(mId_GfxAdapter,GLES2VertexShader);
			shader->vs = shaderId;

			*_ppDst = shader;
			return true;
		}
		else
			return false;
	}

	 // ------------------------------------------------------------------------------

	bbool GFXAdapter_OpenGLES2::loadPShaderFromMemory(GLES2PixelShader **_ppDst, const void *_pSrc, ux _binSize)
	{
		GLES2PixelShader *shader;
		GLuint shaderId = compileShader(GL_FRAGMENT_SHADER, (const char*)_pSrc);

		if ( shaderId )
		{
			shader = newAlloc(mId_GfxAdapter,GLES2PixelShader);
			shader->ps = shaderId;

			*_ppDst = shader;
			return true;
		}
		else
			return false;
	}

	void GFXAdapter_OpenGLES2::releaseShader( ITF_shader* _shaderGroup )
	{
		ShaderMapIterator posVs = _shaderGroup->mp_hashVs.begin();
		while (posVs != _shaderGroup->mp_hashVs.end())
		{
			freeShaderVS( (GLES2VertexShader*)posVs.getval().microcode  ); 
			++posVs;
		}

		ShaderMapIterator posPs = _shaderGroup->mp_hashPs.begin();
		while (posPs != _shaderGroup->mp_hashPs.end())
		{
			freeShaderPS( (GLES2PixelShader*)posPs.getval().microcode ); 
			++posPs;
		}
	}

 	// ------------------------------------------------------------------------------

	void GFXAdapter_OpenGLES2::freeShaderVS(GLES2VertexShader *_shader)
	{
		if(_shader)
		{
			if(_shader->vs)
				GL_CHECK( glDeleteShader(_shader->vs) );
			delete(_shader);
		}
	}
 	// ------------------------------------------------------------------------------

	void GFXAdapter_OpenGLES2::freeShaderPS(GLES2PixelShader *_shader)
	{
		if(_shader)
		{
			if(_shader->ps)
				GL_CHECK( glDeleteShader(_shader->ps) );
			delete(_shader);
		}
	}

#ifndef ITF_CONSOLE_FINAL
 	// ------------------------------------------------------------------------------

	void GFXAdapter_OpenGLES2::reloadShaders()
	{
		LOG("[SHADER] Reloading shaders ...");

		syncGPU();

		mp_shaderManager.removeShaderGroup(mp_shaderManager.getShaderGroup(mc_shader_AfterFx));
		mp_shaderManager.removeShaderGroup(mp_shaderManager.getShaderGroup(mc_shader_Font));
		mp_shaderManager.removeShaderGroup(mp_shaderManager.getShaderGroup(mc_shader_Movie));
		mp_shaderManager.removeShaderGroup(mp_shaderManager.getShaderGroup(mc_shader_Main));

		loadCoreShaders();

		LOG("[SHADER] Shaders reloaded."); // cf. SHADER_USE_HWFILE
	}
#endif // ITF_CONSOLE_FINAL

 	// ------------------------------------------------------------------------------

	void GFXAdapter_OpenGLES2::setShaderRepartition(f32 _psPercentage)
	{
#if 0 //DEAC
		f32 perc = f32_Clamp(_psPercentage, 0.0f, 100.0f) / 100.0f;
		u32 vsGprs = GX2_TOTAL_GPRS_GS_DISABLED * (1.0f - perc);
		u32 vsStackSize = GX2_TOTAL_STACK_ENTRIES * (1.0f - perc);
		u32 psGprs = GX2_TOTAL_GPRS_GS_DISABLED * perc;
		u32 psStackSize = GX2_TOTAL_GPRS_GS_DISABLED * perc;

		GX2SetShaderModeEx(	GX2_SHADER_MODE_UNIFORM_REGISTER,
							vsGprs,
							vsStackSize,
							0,
							0,
							psGprs,
							psStackSize	 
							);
#endif
	}

 	// ------------------------------------------------------------------------------

	void GFXAdapter_OpenGLES2::setVertexShader(void *_shaderBin)
	{
		//ITF_ASSERT(_shaderBin);
		m_CurrentVertexShader = (GLES2VertexShader *)_shaderBin;
	}

 	// ------------------------------------------------------------------------------

	void GFXAdapter_OpenGLES2::setPixelShader(void *_shaderBin)
	{
		//ITF_ASSERT(_shaderBin);
		m_CurrentPixelShader = (GLES2PixelShader *)_shaderBin;
	}

	GFXAdapter_OpenGLES2::GLES2Program::GLES2Program(GLES2VertexShader *_vertexShader, GLES2PixelShader *_pixelShader)
	{
 		m_positionHandle =GLuint(-1);
 		m_colorHandle = GLuint(-1);
 		m_UV0Handle = GLuint(-1);
		m_UV1Handle = GLuint(-1);
		m_UV2Handle = GLuint(-1);
		m_UV3Handle = GLuint(-1);
		m_blendHandle = GLuint(-1);
		m_usedPSTextureMask = 0;

		m_vertexShader = _vertexShader;
		m_pixelShader = _pixelShader;

		m_programIndex = glCreateProgram();
		if (m_programIndex)
		{
			GL_CHECK( glAttachShader(m_programIndex, m_vertexShader->vs) );
			GL_CHECK( glAttachShader(m_programIndex, m_pixelShader->ps) );
			GL_CHECK( glLinkProgram(m_programIndex) );
            GL_CHECK( glValidateProgram(m_programIndex) );
			GLint linkStatus = GL_FALSE;
			GL_CHECK( glGetProgramiv(m_programIndex, GL_LINK_STATUS, &linkStatus) );
			if (linkStatus != GL_TRUE)
			{
				GLint bufLength = 0;
				GL_CHECK( glGetProgramiv(m_programIndex, GL_INFO_LOG_LENGTH, &bufLength) );
				if (bufLength)
				{
					char* buf = (char*) malloc(bufLength);
					if (buf)
					{
						GL_CHECK( glGetProgramInfoLog(m_programIndex, bufLength, NULL, buf) );
						//LogE("Could not link program:\n%s\n", buf);
						free(buf);
					}
				}
	            
				GL_CHECK( glDeleteProgram(m_programIndex) );
            	m_programIndex = 0;
			}
			else
			{
				parseAttrib();
				parseUniform();
			}
		}
	}

	void GFXAdapter_OpenGLES2::GLES2Program::parseAttrib()
	{
		GLint active_attribs;
		char name[256];
		glGetProgramiv(m_programIndex, GL_ACTIVE_ATTRIBUTES, &active_attribs);

		for (ix i = 0; i < active_attribs; i++)
		{
			GLint size;
			GLenum type;

			glGetActiveAttrib(m_programIndex, i, 256, NULL, &size, &type, name);
			GLint location = glGetAttribLocation(m_programIndex, name);
			if ( strstr(name, "_xPOSITION") )
				m_positionHandle = location;
			else if ( strstr(name, "_xCOLOR0") )
				m_colorHandle = location;
			else if ( strstr(name, "_xTEXCOORD0") )
				m_UV0Handle = location;
			else if ( strstr(name, "_xTEXCOORD1") )
				m_UV1Handle = location;
			else if ( strstr(name, "_xTEXCOORD2") )
				m_UV2Handle = location;
			else if ( strstr(name, "_xTEXCOORD3") )
				m_UV3Handle = location;
			else if ( strstr(name, "_xBLENDINDICES") )
				m_blendHandle = location;

		}
	}

    void GFXAdapter_OpenGLES2::GLES2Program::resetConstantCache()
    {
        ux count = m_constantBindingTableVS.size();
        for (ux i = 0; i < count; ++i)
        {
            GLES2_Uniform_Register_Binding_Float4 & bind = m_constantBindingTableVS[i];
            bind.refData.m_x = bind.refData.m_y = bind.refData.m_z = bind.refData.m_w = 666.0f;
        }
        count = m_constantBindingTablePS.size();
        for (ux i = 0; i < count; ++i)
        {
            GLES2_Uniform_Register_Binding_Float4 & bind = m_constantBindingTablePS[i];
            bind.refData.m_x = bind.refData.m_y = bind.refData.m_z = bind.refData.m_w = 666.0f;
        }

    }
	void GFXAdapter_OpenGLES2::GLES2Program::parseUniform()
	{
// 		GLint error = glGetError();
        // uniforms
        GLint maxFragmentUniform = 0;
        GL_CHECK( glGetIntegerv(GL_MAX_FRAGMENT_UNIFORM_VECTORS, &maxFragmentUniform) );

        GLint maxVertexUniform = 0;
        GL_CHECK( glGetIntegerv(GL_MAX_VERTEX_UNIFORM_VECTORS, &maxVertexUniform) );

        GLint uniformCount = 0;
        GL_CHECK( glGetProgramiv(m_programIndex, GL_ACTIVE_UNIFORMS, &uniformCount) );

        u16 & usedPSTex = m_usedPSTextureMask;
              usedPSTex = 0;

        for (GLint i = 0; i < uniformCount; ++i)
        {
            int name_len=-1, num=-1;
            GLenum type = GL_ZERO;
            char name[250];
            GL_CHECK( glGetActiveUniform( m_programIndex, GLuint(i), sizeof(name)-1, &name_len, &num, &type, name ) );
            name[name_len] = 0;
            GLuint location;
			GL_CHECK( location = glGetUniformLocation( m_programIndex, name ) );
			
			ITF_ASSERT_MSG((GLuint)-1 != location, "Location for \"%s\" not found!", name);
 
            const char * gltypename;
            switch(type)
            {
                default:ITF_ASSERT(0); gltypename = ""; break;

                    //case GL_FLOAT: gltypename = "float"; break;
                    //case GL_FLOAT_VEC2: gltypename = "float2"; break;
                    //case GL_FLOAT_VEC3: gltypename = "float3"; break;
                case GL_FLOAT_VEC4: gltypename = "float4"; break;

                    //case GL_INT: gltypename = "int"; break;
                    //case GL_INT_VEC2: gltypename = "int2"; break;
                    //case GL_INT_VEC3: gltypename = "int3"; break;
                case GL_INT_VEC4: gltypename = "int4"; break;

                case GL_BOOL: gltypename = "bool"; break;
                    //case GL_BOOL_VEC2: gltypename = "bool2"; break;
                    //case GL_BOOL_VEC3: gltypename = "bool3"; break;
                    //case GL_BOOL_VEC4: gltypename = "bool4"; break;

                    //case GL_FLOAT_MAT2: gltypename = "mat2"; break;
                    //case GL_FLOAT_MAT3: gltypename = "mat3"; break;
                    //case GL_FLOAT_MAT4: gltypename = "mat4"; break;

                case GL_SAMPLER_2D: gltypename = "sampler2D"; break;
                case GL_SAMPLER_CUBE: gltypename = "samplerCUBE"; break;
            }

            const char * header = NULL;
            switch(type)
            {
                case GL_SAMPLER_2D:
                case GL_SAMPLER_CUBE:
#ifndef ITF_IOS
                case GL_SAMPLER_3D_OES:
#endif
                    header = "o_x_s";
                    break;

                default:
                    header = "o_x_C";
                    break;
            }

            // get register index from string
            char * nameCopy = (char*)ITF::Memory::malloc(strlen(name)+1);
			strcpy(nameCopy, name);
            const char * regStart = strstr(nameCopy, header);
            if (regStart)
            {
                regStart += strlen(header);
                char * regStop = (char*)strstr(regStart, "_x");
				if( regStop ) // coverity
					*regStop = '\0';
                int regIndex = atoi(regStart);
                
                // check for offset
                int offset = 0;
				strcpy(nameCopy, name);
				for (;;)
				{
					char * offsetStart = strstr(nameCopy, "_offset_");
					if (offsetStart)
					{
						offsetStart[0] = ' '; // remove underscore to remove this offset from next search.
						offsetStart += strlen("_offset_");
						char * offsetStop = (char*)strstr(offsetStart, "_x");
						if( offsetStop != NULL )
						{
							*offsetStop = '\0';
							offset += atoi(offsetStart);
							*offsetStop = '_';
						}
					}
					else
						break;
				}

                // ps or vs?
                //ux len = lynstd::strlen(name);
                GLES2_Uniform_Register_Binding_ProgramType programType = (GLES2_Uniform_Register_Binding_ProgramType)-1;

                if (strstr(name, "_ps")/* == (name+len-3)*/)
                {
                    programType = GLES2_Uniform_Register_Binding_ProgramType_Pixel;
                }
                else if (strstr(name, "_vs")/* == (name+len-3)*/)
                {
                    programType = GLES2_Uniform_Register_Binding_ProgramType_Vertex;
                }
                else
                {
                    ITF_ASSERT(bfalse);
                }
                
                switch(type)
                {
                    case GL_SAMPLER_2D:
                    case GL_SAMPLER_CUBE:
#ifndef ITF_IOS
                    case GL_SAMPLER_3D_OES:
#endif
                    {
                        GLES2_Uniform_Register_Binding_Sampler desc;
                        //desc.num = (u8)num;
                        desc.loc = location;
                        desc.reg = (u8)regIndex;
                        desc.type = (u8)programType;

                        if (programType == GLES2_Uniform_Register_Binding_ProgramType_Pixel)
                        {
                            usedPSTex |= 1<<regIndex;
                            ITF_ASSERT(regIndex < 16);
                        }
                        else
                        {
                            //usedVSTex |= 1<<regIndex;
                            ITF_ASSERT(regIndex < 4);
                        }
						m_samplerBindingTable.push_back(desc);
                    }
                    break;

                    case GL_FLOAT_VEC4 :
                    {
                        regIndex += offset/4;

                        GLES2_Uniform_Register_Binding_Float4 desc;
                        desc.num = (u8)num;
                        desc.loc = location;
                        desc.reg = (u8)regIndex; ITF_ASSERT(regIndex <= 0xFF);
                        desc.type = (u8)programType;
						desc.refData.m_x = desc.refData.m_y = desc.refData.m_z = desc.refData.m_w = 666.0f; // Force a change
						if ( programType == GLES2_Uniform_Register_Binding_ProgramType_Vertex )
							m_constantBindingTableVS.push_back(desc);
						else
							m_constantBindingTablePS.push_back(desc);
                    }
                    break;
                }
            } 

            ITF::Memory::free(nameCopy);
		}
	}

	void GFXAdapter_OpenGLES2::GLES2Program::flushStates(GFXAdapter_OpenGLES2 *_adapter)
	{
		// Set program
		if ( _adapter->m_lastProgram != this )
		{
			GL_CHECK( glUseProgram(m_programIndex) );
			_adapter->m_lastProgram = this;
			_adapter->m_dirtyFlags = 0xffffffff;
		}

		// Set textures and samplers.
		for ( ux i = 0; i < m_samplerBindingTable.size(); i++ )
		{
			GLES2_Uniform_Register_Binding_Sampler &samplerDesc = m_samplerBindingTable[i];
			ux reg = samplerDesc.reg;

			if ( (1UL << reg) & (_adapter->m_dirtyFlags & GLES2_DirtyTexMaskPS ) )
			{
				_adapter->GL_activeTexture(GL_TEXTURE0 + samplerDesc.reg);

				PlatformTexture* temp = _adapter->m_texturePS[reg];
				if (!temp)
					continue;
				GLuint glTexId = temp->hwdData;
				GLenum target = GL_TEXTURE_2D;
				GL_CHECK( glBindTexture(target, glTexId) );

				GL_CHECK( glUniform1i(samplerDesc.loc, samplerDesc.reg ) );
				GL_CHECK( glTexParameteri(target, GL_TEXTURE_WRAP_S, _adapter->m_samplerWrapUPS[reg]) );
				GL_CHECK( glTexParameteri(target, GL_TEXTURE_WRAP_T, _adapter->m_samplerWrapVPS[reg]) );

/*				GL_CHECK( glTexParameteri(target, GL_TEXTURE_MIN_FILTER, _adapter->m_samplerMinFilterPS[reg]) );
				GL_CHECK( glTexParameteri(target, GL_TEXTURE_MAG_FILTER, _adapter->m_samplerMaxFilterPS[reg]) );*/
			}
		}
		_adapter->m_dirtyFlags &= ~GLES2_DirtyTexMaskPS;

		// Set vertex shader constants.
		if ( _adapter->m_dirtyFlags & GLES2_DirtyConstVS )
		{
			ux count = m_constantBindingTableVS.size();
			for (ux i = 0; i < count; ++i)
			{
				GLES2_Uniform_Register_Binding_Float4 & bind = m_constantBindingTableVS[i];

				const ux index = bind.reg;
				const GFX_Vector4 * src = &_adapter->m_vertexShaderConstantGlobalCache[index];

				
                // Disabled for the moment, crashes the water
                /* if( (src->m_x != bind.refData.m_x) ||
					(src->m_y != bind.refData.m_y) || 
					(src->m_z != bind.refData.m_z) || 
					(src->m_w != bind.refData.m_w) ) */
				{
					GL_CHECK( glUniform4fv(bind.loc, bind.num, (const GLfloat*)src ) );
					bind.refData = *src;
				}

			}
			_adapter->m_dirtyFlags &= ~GLES2_DirtyConstVS;
		}

		// Set pixel shader constants.
		if ( _adapter->m_dirtyFlags & GLES2_DirtyConstPS )
		{
			ux count = m_constantBindingTablePS.size();
			for (ux i = 0; i < count; ++i)
			{
				GLES2_Uniform_Register_Binding_Float4 & bind = m_constantBindingTablePS[i];

				const ux index = bind.reg;
				const GFX_Vector4 * src = &_adapter->m_pixelShaderConstantGlobalCache[index];

                // Disabled for the moment, crashes the water
				/* if( (src->m_x != bind.refData.m_x) ||
					(src->m_y != bind.refData.m_y) || 
					(src->m_z != bind.refData.m_z) || 
					(src->m_w != bind.refData.m_w) ) */
				{
					GL_CHECK( glUniform4fv(bind.loc, bind.num, (const GLfloat*)src ) );
					bind.refData = *src;
				}
			}
			_adapter->m_dirtyFlags &= ~GLES2_DirtyConstPS;
		}

		// Set attributes.
		if ( _adapter->m_dirtyFlags & GLES2_DirtyAttribVS )
		{
			GL_CHECK( glBindBuffer(GL_ARRAY_BUFFER, _adapter->m_vertexBufferId) );
			if ( m_positionHandle != -1 )
			{
				shAttr& attribute = _adapter->shAttrArray[shAI_vPos];
				GL_CHECK( glEnableVertexAttribArray(m_positionHandle) );
				GL_CHECK( glVertexAttribPointer(m_positionHandle, attribute.size, attribute.type, attribute.normalized, attribute.stride, attribute.ptr) );
			}
			if ( m_colorHandle != -1 )
			{
				shAttr& attribute = _adapter->shAttrArray[shAI_fColor];
				GL_CHECK( glEnableVertexAttribArray(m_colorHandle) );
				GL_CHECK( glVertexAttribPointer(m_colorHandle, attribute.size, attribute.type, attribute.normalized, attribute.stride, attribute.ptr) );
			}
			if ( m_blendHandle != -1 )
			{
				shAttr& attribute = _adapter->shAttrArray[shAI_vBlendW];
				GL_CHECK( glEnableVertexAttribArray(m_blendHandle) );
				GL_CHECK( glVertexAttribPointer(m_blendHandle, attribute.size, attribute.type, attribute.normalized, attribute.stride, attribute.ptr) );
			}
			if ( m_UV0Handle != -1 )
			{
				shAttr& attribute = _adapter->shAttrArray[shAI_vTexCoord0];
				GL_CHECK( glEnableVertexAttribArray(m_UV0Handle) );
				GL_CHECK( glVertexAttribPointer(m_UV0Handle, attribute.size, attribute.type, attribute.normalized, attribute.stride, attribute.ptr) );
			}
			if ( m_UV1Handle != -1 )
			{
				shAttr& attribute = _adapter->shAttrArray[shAI_uv2];
				GL_CHECK( glEnableVertexAttribArray(m_UV1Handle) );
				GL_CHECK( glVertexAttribPointer(m_UV1Handle, attribute.size, attribute.type, attribute.normalized, attribute.stride, attribute.ptr) );
			}
			if ( m_UV2Handle != -1 )
			{
				shAttr& attribute = _adapter->shAttrArray[shAI_uv3];
				GL_CHECK( glEnableVertexAttribArray(m_UV2Handle) );
				GL_CHECK( glVertexAttribPointer(m_UV2Handle, attribute.size, attribute.type, attribute.normalized, attribute.stride, attribute.ptr) );
			}
			if ( m_UV3Handle != -1 )
			{
				shAttr& attribute = _adapter->shAttrArray[shAI_uv4];
				GL_CHECK( glEnableVertexAttribArray(m_UV3Handle) );
				GL_CHECK( glVertexAttribPointer(m_UV3Handle, attribute.size, attribute.type, attribute.normalized, attribute.stride, attribute.ptr) );
			}
			
			_adapter->m_dirtyFlags &= ~GLES2_DirtyAttribVS;
		}
	}

	GFXAdapter_OpenGLES2::GLES2Program *GFXAdapter_OpenGLES2::getProgramFromShaders(GLES2VertexShader *_vertexShader, GLES2PixelShader *_pixelShader)
	{
		GLES2ProgramKey key = getProgramKey(_vertexShader, _pixelShader);
		GLES2Program *program;
		GLES2Program **programPtr = m_programHash.find(key);
		if ( !programPtr )
		{
			program = newAlloc(mId_GfxAdapter,GLES2Program(_vertexShader, _pixelShader));
			m_programHash.insert(key, program);
		}
		else
			program = *programPtr;
		return program;
	}

	void GFXAdapter_OpenGLES2::releasePrograms()
	{
		for(ITF_HASHMAP<GLES2ProgramKey, GLES2Program*>::const_iterator it = m_programHash.begin(); it!=m_programHash.end(); ++it)
		{
			GLES2Program *program = it.getval();
			delete( program );
		}
	}

	void GFXAdapter_OpenGLES2::resetShaderConstantCache()
	{
		for(ITF_HASHMAP<GLES2ProgramKey, GLES2Program*>::const_iterator it = m_programHash.begin(); it!=m_programHash.end(); ++it)
		{
			GLES2Program *program = it.getval();
			program->resetConstantCache();
		}
	}
 	// ------------------------------------------------------------------------------

	void GFXAdapter_OpenGLES2::setVertexFormat( u32 _vformat )
	{
		m_drawCallStates.vertexFormat = _vformat;
		m_drawCallStates.vertexSize = VertexFormat_TO_StructSize(_vformat);
	}

 	// ------------------------------------------------------------------------------

	void GFXAdapter_OpenGLES2::setIndexBuffer(ITF_IndexBuffer* _indexBuffer)
	{
		m_drawCallStates.indexBuffer = _indexBuffer;

		if(!_indexBuffer->mp_IndexBuffer) return;

		GL_CHECK( glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, (GLuint)_indexBuffer->mp_IndexBuffer) );
	}

 	// ------------------------------------------------------------------------------

	void GFXAdapter_OpenGLES2::setVertexBuffer(ITF_VertexBuffer* _vertexBuffer, u32 _statIdx)
	{
		m_CurrentVertexBuffer = _vertexBuffer;

		//ITF_ASSERT(_vertexBuffer && _vertexBuffer->mp_VertexBuffer);

		setVertexFormat(_vertexBuffer->m_vertexFormat);
		m_drawCallStates.vertexBuffer = _vertexBuffer;
		m_drawCallStates.nbVertices = _vertexBuffer->m_nVertex;
        m_drawCallStates.useInstancing = false;

		m_dirtyFlags |= GLES2_DirtyAttribVS;

		uPtr pointer = 0;
#ifdef _HARDCODED_SHADER
		if (_vertexBuffer->mp_VertexBuffer == 0)
		{
			pointer = _vertexBuffer->m_offset;
			GL_CHECK( glBindBuffer(GL_ARRAY_BUFFER, 0) );
		}
		else
			GL_CHECK( glBindBuffer(GL_ARRAY_BUFFER, (GLuint)_vertexBuffer->mp_VertexBuffer) );
#else
		pointer = _vertexBuffer->m_offset;
		m_vertexBufferId = (GLuint)_vertexBuffer->mp_VertexBuffer;
		
#endif

		switch (_vertexBuffer->m_vertexFormat)
		{
		case VertexFormat_P:
			{
				u32 stride = sizeof(VertexP);

				shAttrArray[shAI_vPos].set(3, GL_FLOAT, GL_FALSE, stride, (void*)pointer);
			}
			break;
		case VertexFormat_PCT:
		{
			u32 stride = sizeof(VertexPCT);
#ifdef _HARDCODED_SHADER
			glEnableVertexAttribArray(gvPositionHandle[0]);
			glEnableVertexAttribArray(gvColorHandle[0]);
			glEnableVertexAttribArray(gvUVHandle[0]);

			glVertexAttribPointer(gvPositionHandle[0], 3, GL_FLOAT, GL_FALSE, stride, (void*)pointer);
			glVertexAttribPointer(gvColorHandle[0], 4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 3 * sizeof(GLfloat))); 
			glVertexAttribPointer(gvUVHandle[0], 2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 3 * sizeof(GLfloat) + sizeof(u32)));
				m_curProg = 0;
#else
			shAttrArray[shAI_vPos].set(3, GL_FLOAT, GL_FALSE, stride, (void*)pointer);
			shAttrArray[shAI_fColor].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 3 * sizeof(GLfloat))); 
			shAttrArray[shAI_vTexCoord0].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 3 * sizeof(GLfloat) + sizeof(u32)));
#endif
		}
			break;
		case VertexFormat_PC:
		{
			u32 stride = sizeof(VertexPC);
#ifdef _HARDCODED_SHADER
			glEnableVertexAttribArray(gvPositionHandle[1]);
			glEnableVertexAttribArray(gvColorHandle[1]);
		
			glVertexAttribPointer(gvPositionHandle[1], 3, GL_FLOAT, GL_FALSE, stride, (void*)pointer);
			glVertexAttribPointer(gvColorHandle[1], 4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 3 * sizeof(GLfloat))); 
				m_curProg = 1;
#else
			shAttrArray[shAI_vPos].set(3, GL_FLOAT, GL_FALSE, stride, (void*)pointer);
			shAttrArray[shAI_fColor].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 3 * sizeof(GLfloat))); 
#endif
			}
			break;
		case VertexFormat_PT:
			{
				u32 stride = sizeof(VertexPT);

				shAttrArray[shAI_vPos].set(3, GL_FLOAT, GL_FALSE, stride, (void*)pointer);
				shAttrArray[shAI_vTexCoord0].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 3 * sizeof(GLfloat)));
			}
			break;
		case VertexFormat_T:
			{
				u32 stride = sizeof(VertexT);

				shAttrArray[shAI_vTexCoord0].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 0));
			}
			break;
		case VertexFormat_PNC3T:
			{
				u32 stride = sizeof(VertexPNC3T);

				shAttrArray[shAI_vPos].set(3, GL_FLOAT, GL_FALSE, stride, (void*)pointer);
				shAttrArray[shAI_fColor].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 12));
				shAttrArray[shAI_vTexCoord0].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 16));
				shAttrArray[shAI_uv2].set(4, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 24));
				shAttrArray[shAI_uv3].set(4, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 40));
				shAttrArray[shAI_uv4].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 56));
			}
			break;
		case VertexFormat_PC2T:
			{
				u32 stride = sizeof(VertexPC2T);

				shAttrArray[shAI_vPos].set(3, GL_FLOAT, GL_FALSE, stride, (void*)pointer);
				shAttrArray[shAI_fColor].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 12));
				shAttrArray[shAI_vTexCoord0].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 16));
				shAttrArray[shAI_uv2].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 24));
			}
			break;
		case VertexFormat_PCTBIBW:
			{
				u32 stride = sizeof(VertexPCTBIBW);

				shAttrArray[shAI_vPos].set(3, GL_FLOAT, GL_FALSE, stride, (void*)pointer);
				shAttrArray[shAI_fColor].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 12)); 
				shAttrArray[shAI_vBlendW].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 16)); 
				shAttrArray[shAI_vChnl].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 20));
				shAttrArray[shAI_vTexCoord0].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 24));
			}
			break;
		case VertexFormat_PCBT:
			{
				u32 stride = sizeof(VertexPCBT);

				shAttrArray[shAI_vPos].set(3, GL_FLOAT, GL_FALSE, stride, (void*)pointer);
				shAttrArray[shAI_fColor].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 12)); 
				shAttrArray[shAI_vBlendW].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 16)); 
				shAttrArray[shAI_vTexCoord0].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 20));
			}
			break;
		case VertexFormat_PCB2T:
			{
				u32 stride = sizeof(VertexPCB2T);

				shAttrArray[shAI_vPos].set(3, GL_FLOAT, GL_FALSE, stride, (void*)pointer);
				shAttrArray[shAI_fColor].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 12)); 
				shAttrArray[shAI_vBlendW].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 16)); 
				shAttrArray[shAI_vTexCoord0].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 20));
				shAttrArray[shAI_uv2].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 28));
			}
			break;
		case VertexFormat_PNCT:
			{
				u32 stride = sizeof(VertexPNCT);

				shAttrArray[shAI_vPos].set(3, GL_FLOAT, GL_FALSE, stride, (void*)pointer);
				shAttrArray[shAI_vNrm].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 12));
				shAttrArray[shAI_vTgt].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 16));
				shAttrArray[shAI_fColor].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 20)); 
				shAttrArray[shAI_vTexCoord0].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 24));
			}
			break;
		case VertexFormat_QuadInstance_2TC:
			{
				u32 stride = sizeof(VertexQI_2TC) / 4;

				shAttrArray[shAI_vTexCoord0].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 0));
				shAttrArray[shAI_uv2].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 8));
				shAttrArray[shAI_uv3].set(2, GL_FLOAT, GL_FALSE, stride, (void*) (pointer + 16));
				shAttrArray[shAI_fColor].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 24)); 
			}
			break;
		case VertexFormat_I:
			{
				u32 stride = sizeof(VertexI);

				shAttrArray[shAI_vBlendW].set(4, GL_UNSIGNED_BYTE, GL_TRUE, stride, (void*) (pointer + 0)); 
			}
			break;
		default:
#if !(defined ITF_IOS || defined ITF_ANDROID)
			ITF_ASSERT(0);
#endif
			break;
		}
	}

#if 0 //DEAC
#ifdef CHECK_SHADERS_VALIDITY
	static ShaderParameterDBDesc::ParamType GX2VarType_2_ParamType(GX2VarType _type)
	{
		switch(_type)
		{
		case GX2_VAR_TYPE_FLOAT:    return ShaderParameterDBDesc::PARAM_TYPE_float;
		case GX2_VAR_TYPE_VEC2:     return ShaderParameterDBDesc::PARAM_TYPE_float2;
		case GX2_VAR_TYPE_VEC3:     return ShaderParameterDBDesc::PARAM_TYPE_float3;
		case GX2_VAR_TYPE_VEC4:     return ShaderParameterDBDesc::PARAM_TYPE_float4;
		case GX2_VAR_TYPE_MAT4:     return ShaderParameterDBDesc::PARAM_TYPE_float4x4;
		case GX2_VAR_TYPE_MAT3X4:   return ShaderParameterDBDesc::PARAM_TYPE_BoneMatrix;
		}

		return ShaderParameterDBDesc::PARAM_TYPE_Count;
	}
#endif

#if 0
	static GX2VarType GX2AttribFormat_2_GX2VarType(GX2AttribFormat _format)
	{
		switch(_format)
		{
		case GX2_ATTRIB_FORMAT_32_32_32_FLOAT:      return GX2_VAR_TYPE_VEC4;
		case GX2_ATTRIB_FORMAT_8_8_8_8_UNORM:       return GX2_VAR_TYPE_VEC4;
		case GX2_ATTRIB_FORMAT_8_8_8_8_SINT:        return GX2_VAR_TYPE_IVEC4;
		case GX2_ATTRIB_FORMAT_32_32_FLOAT:         return GX2_VAR_TYPE_VEC2;
		case GX2_ATTRIB_FORMAT_32_32_32_32_FLOAT:   return GX2_VAR_TYPE_VEC4;
		}

		return GX2_VAR_TYPE_VOID;
	}
#endif

 	// ------------------------------------------------------------------------------

	void GFXAdapter_OpenGLES2::CheckUniformVar(const ShaderParameterDBDesc *_dbDesc, const GX2UniformVar *_var)
	{
#if 0 //DEAC
		#define COUNT_2_U32s(c)     ((c)/sizeof(u32))

		const char *schr = NULL;

		// Array Element
		if((schr = strchr(_var->name, '[')) != NULL)
		{
			char arrayName[256];
			u32 len = schr - _var->name;
			strncpy(arrayName, _var->name, len);
			arrayName[len] = '\0';

			u32 elemID = 0;
			ITF_VERIFY(sscanf(schr, "[%d]", &elemID));
			u32 nbReg = elemID * COUNT_2_U32s(GX2VarTypeToCount(_var->type));

			const ShaderParameterDBDesc::const_iterator &it = _dbDesc->find(arrayName);
			if(it == _dbDesc->end())
				ITF_WARNING(NULL, bfalse, "Uniform array '%s' not found", arrayName);
			else if((it->firstReg != (COUNT_2_U32s(_var->offset)-nbReg)) || (it->nbReg < nbReg))
				ITF_WARNING(NULL, bfalse, "Uniform field array '%s' register mismatch (%d != %d || %d < %d)", _var->name, it->firstReg, COUNT_2_U32s(_var->offset)-nbReg, it->nbReg, nbReg);
			else if((it->nbReg != (_var->arrayCount * COUNT_2_U32s(GX2VarTypeToCount(_var->type)))))
				ITF_WARNING(NULL, bfalse, "Uniform array '%s' num registers mismatch (%d != %d)", arrayName, it->nbReg, _var->arrayCount * COUNT_2_U32s(GX2VarTypeToCount(_var->type)));
			else if((it->type != GX2VarType_2_ParamType(_var->type)) || (it->isArray != btrue) || (it->isStruct != bfalse))
				ITF_WARNING(NULL, bfalse, "Uniform array '%s' type mismatch", arrayName);
		}

#if (CAFE_OS_SDK_VERSION >= 20400)
		// Array Name
		else if(_var->arrayCount > 1)
		{
			const ShaderParameterDBDesc::const_iterator &it = _dbDesc->find(_var->name);
			if(it == _dbDesc->end())
				ITF_WARNING(NULL, bfalse, "Uniform array '%s' not found", _var->name);
			else if(it->firstReg != COUNT_2_U32s(_var->offset))
				ITF_WARNING(NULL, bfalse, "Uniform array '%s' register mismatch (%d != %d)", _var->name, it->firstReg, COUNT_2_U32s(_var->offset));
			else if((it->nbReg != (_var->arrayCount * COUNT_2_U32s(GX2VarTypeToCount(_var->type)))))
				ITF_WARNING(NULL, bfalse, "Uniform array '%s' num registers mismatch (%d != %d)", _var->name, it->nbReg, _var->arrayCount * COUNT_2_U32s(GX2VarTypeToCount(_var->type)));
			else if((it->type != GX2VarType_2_ParamType(_var->type)) || (it->isArray != btrue) || (it->isStruct != bfalse))
				ITF_WARNING(NULL, bfalse, "Uniform array '%s' type mismatch", _var->name);
		}
#endif // (CAFE_OS_SDK_VERSION >= 20400)
		// Struct
		else if((schr = strchr(_var->name, '.')) != NULL)
		{
			char structName[256];
			u32 len = schr - _var->name;
			strncpy(structName, _var->name, len);
			structName[len] = '\0';

			const ShaderParameterDBDesc::const_iterator &it = _dbDesc->find(structName);
			if(it == _dbDesc->end())
				ITF_WARNING(NULL, bfalse, "Uniform struct '%s' not found", structName);
			else if((it->firstReg+it->nbReg) < COUNT_2_U32s(_var->offset))
				ITF_WARNING(NULL, bfalse, "Uniform field struct '%s' register mismatch (%d < %d)", _var->name, it->firstReg+it->nbReg, COUNT_2_U32s(_var->offset));
			else if((it->type != ShaderParameterDBDesc::PARAM_TYPE_struct) || (it->isArray != bfalse) || (it->isStruct != btrue))
				ITF_WARNING(NULL, bfalse, "Uniform struct '%s' type mismatch", structName);
		}
		// Simple Var
		else
		{
			const ShaderParameterDBDesc::const_iterator &it = _dbDesc->find(_var->name);
			if(it == _dbDesc->end())
				ITF_WARNING(NULL, bfalse, "Uniform var '%s' not found", _var->name);
			else if(it->firstReg != COUNT_2_U32s(_var->offset))
				ITF_WARNING(NULL, bfalse, "Uniform var '%s' register mismatch (%d != %d)", _var->name, it->firstReg, COUNT_2_U32s(_var->offset));
			else if((it->type != GX2VarType_2_ParamType(_var->type)) || (it->isArray != bfalse) || (it->isStruct != bfalse))
				ITF_WARNING(NULL, bfalse, "Uniform var '%s' type mismatch", _var->name);
		}
#endif
	}

 	// ------------------------------------------------------------------------------

#if 0 //DEAC
	bbool GFXAdapter_OpenGLES2::CheckAttribVar(const GX2AttribVar *_var)
	{
		for(u32 i=0 ; i<shAI_Max ; ++i)
		{
			if(_var->location == shAttrArray[i].location)
			{
				if(_var->type != GX2AttribFormat_2_GX2VarType(shAttrArray[i].format))
				{
					ITF_WARNING(NULL, bfalse, "Attribute var '%s' (loc %d) type mismatch (%d != %d)", _var->name, _var->location, _var->type, GX2AttribFormat_2_GX2VarType(shAttrArray[i].format));
					return bfalse;
				}
				return btrue;
			}
		}

		ITF_WARNING(NULL, bfalse, "Attribute var '%s' not found (loc = %d)", _var->name, _var->location);
		return bfalse;
	}
#endif

 	// ------------------------------------------------------------------------------
#if 0 //DEAC
	void GFXAdapter_OpenGLES2::CheckSamplerVar(const GX2SamplerVar *_var)
	{
		if(_var->location >= MaxSampler)
			ITF_WARNING(NULL, bfalse, "Sampler var '%s' out of bound (loc = %d)", _var->name, _var->location);
	}
#endif // CHECK_SHADERS_VALIDITY
#endif	

 	// ------------------------------------------------------------------------------

#ifdef CHECK_RUNTIME_SHADER
	void GFXAdapter_OpenGLES2::CheckRuntimeShader()
	{
		ITF_ASSERT(m_CurrentVertexShader);
		ITF_ASSERT(m_CurrentPixelShader);
		ITF_ASSERT(m_CurrentFetchShader);

		struct ShFormat
		{
			u32 location;
			u32 attribut;
		};
		ShFormat shFormatArray[shAI_Max] = {
			 { 0, VF_XYZ                    }  // shAI_vPos
			,{ 2, VF_NORMAL                 }  // shAI_vNrm
			,{ 3, VF_DIFFUSE                }  // shAI_fColor
			,{ 5, VF_BLENDWEIGHT |VF_DWORD  }  // shAI_vBlendW
			,{ 7, VF_BLENDINDICES|VF_DWORD  }  // shAI_vChnl
			,{ 8, VF_TEX1                   }  // shAI_vTexCoord0
			,{ 9, VF_TEX2                   }  // shAI_uv2
			,{10, VF_TEX3                   }  // shAI_uv3
			,{11, VF_TEX4                   }  // shAI_uv4
			,{12, VF_TEX5                   }  // shAI_uv5
		};

		// Check Attributes
		if(m_CurrentVertexShader->numAttribs != m_CurrentFetchShader->attribsCount)
		{
			ITF_WARNING(NULL, bfalse, "Shader Attributes number mismatch (VS=%d != FS=%d)", m_CurrentVertexShader->numAttribs, m_CurrentFetchShader->attribsCount);
		}
		else
		{
			for(u32 i=0 ; i<m_CurrentVertexShader->numAttribs ; ++i)
			{
				// Check VertexFormat
				u32 j;
				for(j=0 ; j<shAI_Max ; ++j)
				{
					if(m_CurrentVertexShader->attribVars[i].location == shFormatArray[j].location)
					{
						if(!(m_drawCallStates.vertexFormat & shFormatArray[j].attribut))
							ITF_WARNING(NULL, bfalse, "Shader Attribute '%s' (loc %d) type mismatch (VF=%08X)", m_CurrentVertexShader->attribVars[i].name, m_CurrentVertexShader->attribVars[i].location, (u32)m_drawCallStates.vertexFormat);
						break;
					}
				}
				if(j >= shAI_Max)
				{
					ITF_WARNING(NULL, bfalse, "Shader Attribute '%s' not found (loc=%d)", m_CurrentVertexShader->attribVars[i].name, m_CurrentVertexShader->attribVars[i].location);
					break;
				}

				// Check FetchShader
				for(j=0 ; j<m_CurrentFetchShader->attribsCount ; ++j)
				{
					if(m_CurrentVertexShader->attribVars[i].location == m_CurrentFetchShader->attribs[j].location)
					{
						if(m_CurrentVertexShader->attribVars[i].type != GX2AttribFormat_2_GX2VarType(m_CurrentFetchShader->attribs[j].format))
							ITF_WARNING(NULL, bfalse, "Shader Attribute '%s' (loc %d) type mismatch (%d != %d)",
								m_CurrentVertexShader->attribVars[i].name, m_CurrentVertexShader->attribVars[i].location, m_CurrentVertexShader->attribVars[i].type, GX2AttribFormat_2_GX2VarType(m_CurrentFetchShader->attribs[j].format));
						break;
					}
				}
				if(j >= m_CurrentFetchShader->attribsCount)
				{
					ITF_WARNING(NULL, bfalse, "Shader Attribute '%s' not found (loc=%d)", m_CurrentVertexShader->attribVars[i].name, m_CurrentVertexShader->attribVars[i].location);
					break;
				}
			}
		}

		// Check Samplers
		for(u32 i=0 ; i<m_CurrentPixelShader->numSamplers ; ++i)
		{
			if(m_CurrentPixelShader->samplerVars[i].location >= MaxSampler)
				ITF_WARNING(NULL, bfalse, "Pixel Sampler '%s' out of bound (loc = %d)", m_CurrentPixelShader->samplerVars[i].name, m_CurrentPixelShader->samplerVars[i].location);
			else
			{
				//if(!shSampArray[ m_CurrentPixelShader->samplerVars[i].location ].texture)
				//	ITF_WARNING(NULL, bfalse, "Pixel Sampler '%s' is missing (loc = %d)", m_CurrentPixelShader->samplerVars[i].name, m_CurrentPixelShader->samplerVars[i].location);
			}
		}
	}
#endif // CHECK_RUNTIME_SHADER

} // namespace ITF
